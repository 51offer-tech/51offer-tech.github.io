{"pages":[{"title":"关于我","text":"我是一个大龄低学历程序猿，虽然不是非常热爱代码，但是还是喜欢折腾，如果有兴趣交流，可以加我QQ:188781475","link":"/about/index.html"}],"posts":[{"title":"golang平滑升级服务","text":"不中断服务进行服务升级 最近在学习go语言，想着用gin+gorm来做一个微信小程序，在gin的github中看到了如何优雅的重启或者停止，因为在生产项目中，如果强行kill掉的话会造成正在执行的业务中断、用户访问被拒绝。显然，平滑的重启或升级我们的应用是多么的重要。 .net的发布过程我做了很多年的.net ，但是从来没有想过如何去平滑更新服务端，也是因为业务要求的可用性不高。一般发布新版本都是采用最笨拙的方式，就是发通知(xx时间升级会暂停服务)-&gt;到点停止服务备份、copy新文件-&gt;启动服务。 java的发布过程在用java做项目的时候，当时就用到了nginx中的upstream来负载均衡，当然，这时候要求的可用性较高，所以在发布服务的时候，就不能再采用简单粗暴的停止-启动大法。我们可以配合nginx -s reload来实现后端服务的灰度发布并且让用户无感知。 golang的发布过程Graceful restart or stopgolang中有很多开源的解决方案：endlessgraceoverseer 实践出真知在这里我们来试试grace(star最多，commits最多)，在github上面有详细的demo和测试步骤。v1 12345router := gin.Default()router.GET(&quot;/&quot;, func(c *gin.Context) { c.String(http.StatusOK, &quot;Welcome Gin Server&quot;)})gracehttp.Serve(&amp;http.Server{Addr:&quot;:8080&quot;,Handler:router}) v2 12345router := gin.Default()router.GET(&quot;/&quot;, func(c *gin.Context) { c.String(http.StatusOK, &quot;Welcome Gin New Server&quot;)})gracehttp.Serve(&amp;http.Server{Addr:&quot;:8080&quot;,Handler:router}) 如果是在windows环境下开发，会提示: 1github.com\\facebookgo\\grace\\gracehttp\\http.go:104:53: undefined: syscall.SIGUSR2 貌似是因为grace不支持windows的原因，我们可以暂时不用搭理他，先编译一个二进制文件， 123SET GOARCH=amd64SET GOOS=linuxgo build main.go 把生成好的文件复制到linux上，先启动起来(我是用的nohup ./grace &amp;来启动的)，这时候我们查看pid是多少 1234ps -ef|grep graceroot 11915 11364 0 13:06 pts/0 00:00:00 ./graceroot 11921 11364 0 13:08 pts/0 00:00:00 grep --color=auto grace 此时访问服务结果：这时候，我们把之前的文件备份，将v2的代码编译好并拷贝上去，执行命令 123456kill -USR2 11915这时候在看看应用进程ps -ef|grep graceroot 11928 1 0 13:11 pts/0 00:00:00 ./graceroot 11935 11364 0 13:12 pts/0 00:00:00 grep --color=auto grace pid已经变为11928,此时访问服务结果：[参考]https://github.com/facebookarchive/gracehttps://github.com/gin-gonic/gin","link":"/2019/10/24/golang%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E6%9C%8D%E5%8A%A1/"},{"title":"Go在Windows下编译linux可执行二进制文件","text":"完成Golang应用开发之后，接下来肯定就是编译成可执行文件，如果开发环境是Windows的话，我们想要编译成可执行文件会非常方便,执行go build即可。但是我们想要编译成Linux环境下可执行的文件呢？ 完成Golang应用开发之后，接下来肯定就是编译成可执行文件，如果开发环境是Windows的话，我们想要编译成可执行文件会非常方便,执行go build即可。但是我们想要编译成Linux环境下可执行的文件呢？我们需要修改几个参数： 1234SET CGO_ENABLED=0SET GOARCH=amd64SET GOOS=linuxgo build main.go 一次执行以上命令，就可以在项目目录生成一个二进制文件，所修改的变量值仅对当前窗口有效，可以如果我们每次都需要输入这些命令的话，着实还是有些繁琐，那么，我们可以新建一个bat文件，将命令复制到bat文件中，以后每次就只需要执行这个bat文件即可。如果又想编译成Windows文件，要么就是关闭窗口重新打开，要么就是修改变量值： 1234SET CGO_ENABLED=1SET GOARCH=SET GOOS=windowsgo build main.go","link":"/2019/11/03/Go%E5%9C%A8Windows%E4%B8%8B%E7%BC%96%E8%AF%91linux%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"},{"title":"nginx搭建https服务","text":"nginx搭建https服务,转发到http后端服务 花了差不多5个小时用golang做了一个短域名服务+简单的微信小程序，在发布的时候需要用过https协议的服务，遂出此文 gin发布https因为是第一次用gin发布一个真实的环境，很多东西也不是很熟，所以只能百度，当时找到gin中间件把端口转换为https协议这篇文章，看了一下，很简单，就尝试着cv实现以下。由于的采用了gin在github提到的Graceful restart or stop功能，简单cv没有实现，就想了一个便捷的方式(毕竟菜嘛)–采用nginx代理一层。 采用nginx部署https安装步骤 123456789101112# 安装依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel# 下载nginxwget http://nginx.org/download/nginx-1.17.4.tar.gz# 解压文件tar -zxvf nginx-1.17.4.tar.gz# 进入nginx源码目录cd nginx-1.17.4# 配置https模块./configure --prefix=/root/nginx --with-http_stub_status_module --with-http_ssl_module# 编译并安装make &amp;&amp; make install 如果上面的步骤没有异常，那么久算安装成功了，下面就开始配置https代理。 1、先把申请下来的证书复制到nginx目录下，我是新建了一个cert的文件目录，2、修改nginx.conf123456789101112131415161718192021server { listen 443 ssl; server_name domain; ssl_certificate /root/nginx/cert/1_domain_bundle.crt; #证书公钥 ssl_certificate_key /root/nginx/cert/2_domain.key; #证书私钥 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDH:AESGCM:HIGH:!RC4:!DH:!MD5:!3DES:!aNULL:!eNULL; ssl_prefer_server_ciphers on; location / { proxy_pass http://0.0.0.0:80; proxy_redirect off; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Cookie $http_cookie; #proxy_cookie_path chunked_transfer_encoding off; } } 3、进入到nginx目录执行sbin/nginx执行二进制文件启动nginx服务，如果修改了conf配置文件，则执行sbin/nginx -s reload 刷新配置。至此，nginx服务便搭建好了。在微信小程序开发设置里面配置好https的域名地址，就可以愉快的玩耍了。","link":"/2019/10/24/nginx%E6%90%AD%E5%BB%BAhttps%E6%9C%8D%E5%8A%A1/"},{"title":"AccessibilityService自动刷视频","text":"使用AccessibilityService实现自动刷视频，赚点小钱 最近很多人在推精简版的快手、抖音等app来赚钱，邀请人之后，可得佣金，每天刷视频也可以的金币换RMB，所以一些闲来无事的人就整体拿着手机刷刷刷，那么有没有什么自动的方式，让我们解放双手呢？Android自动化测试的框架比较多，大家可以自行百度。下面就介绍几种常用的： 模拟MotionEvent这个功能只能给自己本身的app发送Event，无法跨App。 Instrumentation现在有很多基于Instrumentation的自动化测试框架，但是也无法跨App操作，如果想要跨App的话，就只有获得root权限或者系统签名。这两种方式都有些麻烦。 ADB命令需要在PC端执行adb命令，那么就需要USB连接到电脑上，在PC端发送input的shell脚本命令，如果再手机端执行input tap等命令，也需要root权限。操作还是很麻烦 AccessibilityService服务现在很多复制工具都是基于AccessibilityService开发的，通过给予一定的权限，监听手机端的动作，然后查找相应节点，向指定节点发送相应的指令。为了节约时间，我在百度找到一篇文章AccessibilityService实现文本的自动全选黏贴、点击、滑动。利用dispatchGesture+AccessibilityService来实现自动刷新视频，我将其稍作修改，就可以对刷抖音、快手、趣多多等app进行跨应用刷视频，这样一来省了不少时间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void slideVertical(int startSlideRatio, int stopSlideRatio) { sliderCount++; int screenHeight = ScreenUtils.getScreenHeight(getApplicationContext()); int screenWidth = ScreenUtils.getScreenWidth(getApplicationContext()); L.e(&quot;屏幕：&quot; + (screenHeight - (screenHeight / 10)) + &quot;/&quot; + (screenHeight - (screenHeight - (screenHeight / 10))) + &quot;/&quot; + screenWidth / 2); Path path = new Path(); int start = (screenHeight / 20) * startSlideRatio; int stop = (screenHeight / 20) * stopSlideRatio; L.e(&quot;屏幕：&quot; + start + &quot;/&quot; + stop + &quot;/&quot; + screenWidth / 2); path.moveTo(screenWidth / 2, start);//如果只是设置moveTo就是点击 path.lineTo(screenWidth / 2, stop);//如果设置这句就是滑动 StringBuffer sb = new StringBuffer(); sb.append(&quot;滑动次数&quot; + sliderCount + &quot;次\\n&quot;); sb.append(&quot;滑动时间&quot; + Utils.formatUTC(System.currentTimeMillis(),null) + &quot;\\n&quot;); sb.append(&quot;开始位置&quot; + start + &quot;\\n&quot;); sb.append(&quot;结束位置&quot; + stop + &quot;\\n&quot;); Intent mIntent = new Intent(MainActivity.RECEIVER_ACTION); mIntent.putExtra(&quot;result&quot;, sb.toString()); //发送广播 sendBroadcast(mIntent); GestureDescription.Builder builder = new GestureDescription.Builder(); GestureDescription gestureDescription = builder .addStroke(new GestureDescription. StrokeDescription(path, 200, 200)) .build(); dispatchGesture(gestureDescription, new GestureResultCallback() { @Override public void onCompleted(GestureDescription gestureDescription) { super.onCompleted(gestureDescription); L.w(&quot;滑动结束&quot; + gestureDescription.getStrokeCount()); } @Override public void onCancelled(GestureDescription gestureDescription) { super.onCancelled(gestureDescription); L.w(&quot;滑动取消&quot;); } }, null); } 效果图:","link":"/2019/10/24/AccessibilityService%E8%87%AA%E5%8A%A8%E5%88%B7%E8%A7%86%E9%A2%91/"},{"title":"Linux中inode引起的故障","text":"inode是什么？ ETL脚本调度故障今日一大早，用户群就炸了，很多人说脚本调度无法运行，一直是未开始状态，起初，我并未引起重视，猜想可能是pieline服务阻塞引起的，由于情况紧急，就直接进入到tomcat manager进行reload操作，但是奇怪的是，reload之后，大批量的作业都直接终止掉，查看日志，发现是ETL脚本日志创建失败， 遂想到，肯定是文件系统占满，就开始rm一部分，然后，df -h，发现还有160+G，以为问题就解决掉了，但是没过多久，依然有很多未开始的作业。 df -i 解围因为对linux使用不是很熟，也只会ps -ef、cd、kill等常用命令，在百度中得知一个命令df -i，执行命令后，发现使用率100%，原来，真正的原因是：etl工具每天产生的小文件过多，把inode占满，导致工具无法创建日志文件。既然找到原因，当然就只有找到目录，将历史文件给rm掉 df的用法df命令一般用于查看磁盘空间大小，du -sh 查看当前目录使用大小。df -h 大文件占用大量的磁盘容量。df -i 过多的文件占用了大量的inode号。 [参考]linux命令df中df -h和df -i的区别","link":"/2019/10/24/Linux%E4%B8%ADinode%E5%BC%95%E8%B5%B7%E7%9A%84%E6%95%85%E9%9A%9C/"},{"title":".net core使用Topshelf注册windows服务","text":"Topshelf注册windows服务，方便快捷 我们经常会用一些定时处理的任务，在.net种一般是结合Quartz或者hangfire这两个组件实现定时周期性作业，但是我想把开发好的定时作业注册成windows服务，这样，在服务器重启之后，可以自动运行服务。Topshelf 就可以很方便的开发windows，而且注册安装也很方便。TopShelf的地址：http://topshelf-project.com/我们首先使用netget安装TopShelf： 1Install-Package TopShelf 然后在program.cs中加入如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243var builder = new HostBuilder() .ConfigureAppConfiguration(config =&gt; { config.AddJsonFile(&quot;monitor.json&quot;, optional: true, reloadOnChange: true); }) .ConfigureServices((hostContext, services) =&gt; { services.Configure&lt;Config&gt;(hostContext.Configuration.GetSection(&quot;monitor&quot;)); services.AddSingleton&lt;IHostLifetime, TopshelfLifetime&gt;(); services.AddHostedService&lt;MonitorService&gt;(); });HostFactory.Run(service =&gt; { service.SetServiceName(&quot;服务名&quot;); service.SetDisplayName(&quot;服务显示名称&quot;); service.SetDescription(&quot;服务描述&quot;); service.UseLog4Net(&quot;log4net.config&quot;); service.Service&lt;IHost&gt;(host =&gt; { host.ConstructUsing(() =&gt; builder.Build()); host.WhenStarted(serviceInstance =&gt; { serviceInstance.StartAsync(); }); host.WhenStopped(serviceInstance =&gt; { serviceInstance.StopAsync(); }); }); service.OnException((ex) =&gt; { Console.WriteLine(&quot;Exception thrown - &quot; + ex.Message); }); service.RunAsLocalSystem(); }); } 新建一个类继承IHostedService接口: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MonitorService : IHostedService, IDisposable { private IScheduler scheduler; static readonly LogWriter _log = HostLogger.Get&lt;MonitorService&gt;(); public readonly Config Config; private Timer _timer; Config _config; public MonitorService() { } public MonitorService(IOptions&lt;Config&gt; config) { _config = config?.Value; //Config = _config; } public async Task StartAsync(CancellationToken cancellationToken) { _log.Info(&quot;service starting&quot;); ISchedulerFactory sf = new StdSchedulerFactory(); scheduler = await sf.GetScheduler(); IJobDetail job = JobBuilder.Create&lt;AreaSyncJob&gt;().WithIdentity(&quot;job1&quot;, &quot;group1&quot;).Build(); ITrigger trigger = TriggerBuilder.Create().WithIdentity(&quot;triggger1&quot;, &quot;group1&quot;).WithSchedule(CronScheduleBuilder.CronSchedule(new CronExpression(_config.AreaJobCronExpr))).Build(); IJobDetail job1 = JobBuilder.Create&lt;LocationSyncJob&gt;().WithIdentity(&quot;job2&quot;, &quot;group2&quot;).Build(); ITrigger trigger1 = TriggerBuilder.Create().WithIdentity(&quot;triggger2&quot;, &quot;group2&quot;).WithSchedule(CronScheduleBuilder.CronSchedule(new CronExpression(_config.LocationCronExpr))).Build(); IJobDetail job2 = JobBuilder.Create&lt;TaskExecAyncJob&gt;().WithIdentity(&quot;job3&quot;, &quot;group3&quot;).Build(); ITrigger trigger2 = TriggerBuilder.Create().WithIdentity(&quot;triggger3&quot;, &quot;group3&quot;).WithSchedule(CronScheduleBuilder.CronSchedule(new CronExpression(_config.TaskExecCronExpr))).Build(); IJobDetail job3 = JobBuilder.Create&lt;MonitorJob&gt;().WithIdentity(&quot;job4&quot;, &quot;group4&quot;).Build(); ITrigger trigger3 = TriggerBuilder.Create().WithIdentity(&quot;triggger4&quot;, &quot;group4&quot;).WithSchedule(CronScheduleBuilder.CronSchedule(new CronExpression(_config.MonitorCronExpr))).Build(); //启动任务 await scheduler.ScheduleJob(job, trigger); await scheduler.ScheduleJob(job1, trigger1); await scheduler.ScheduleJob(job2, trigger2); await scheduler.ScheduleJob(job3, trigger3); await scheduler.Start(); _log.Info(&quot;service started&quot;); } public Task StopAsync(CancellationToken cancellationToken) { _timer?.Change(Timeout.Infinite, 0); scheduler?.Shutdown(); return Task.CompletedTask; } public void Dispose() { scheduler = null; _timer?.Dispose(); } } StartAsync方法为服务启动时运行。然后编译程序： 1dotnet publish -o ./bin/output -c Release -r win7-x64 执行成功后，会在bin/output目录下生成运行所需要的的程序和依赖DLL。将整个目录复制到指定服务器，cmd进入到程序目录，执行： 1xxxx.exe install 就可以完成服务安装.执行: 1xxxx.exe uninstall 就可以完成服务卸载，非常方便。","link":"/2019/10/31/net-core%E4%BD%BF%E7%94%A8Topshelf%E6%B3%A8%E5%86%8Cwindows%E6%9C%8D%E5%8A%A1/"},{"title":"高德地图和google地图整合","text":"整合百度和google地图 因为高德地图的卫星地图不全，但是在高德地图没有的地方，google地图却有，所以客户有一个需求，就是当高德地图显示”无卫星地图”的时候，就显示google地图的图片。 求助万能的百度当然，因为对地图api不是很熟悉，所以就只有百度和看高德官方文档，但是都没有找到合适的解决方案，有看到叠加地图图层并自定义图片路径，这显然不适合我目前的场景，另外一个就是通过API来叠加地图，结合api判断大概的x-y-z的数值范围来加载不同的切片路径. 1234567891011google = new AMap.TileLayer({ map: map, zIndex: 70, //图块取图地址 getTileUrl: function (x, y, z) { //console.log(arguments); if (x &gt;= 12931 &amp;&amp; y &gt;= 3364 &amp;&amp; z &gt;= 16) return &quot;http://mt0.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&quot; + x + &quot;&amp;y=&quot; + y + &quot;&amp;z=&quot; + z + &quot;&amp;s=Galile&quot;; } }); 当然，这种方式解决起来并不优雅，而且客户也反馈过，很多地方google有卫星地图但是现在依然没有，因为如果要加载得更细，就要判断更多的xyz，所以处理起来也不方便。 突发奇想之后，突然想到，为何不在服务端来判断当前切片是否是正常的卫星地图切片，如果不是则去请求google地图的切片，采用这种方式的话，那么就需要修改jsapi，但是高德并不提供离线的js api，怎么办呢？ 当然办法是肯定有的，就是自己去下载一个高德js api，然后把卫星地图模式所指向的地址改为自己的服务端地址即可，项目中就引用自己下载的离线js。js api修改代码： 123456在离线js中查询关键字:autonavi.com/appmaptile?style=6可以找到这样的地址:http://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=6&amp;x=[x]&amp;y=[y]&amp;z=[z]将其修改为自己的代理地址:http://211.137.xxx.xxx/map/?style=6&amp;x=[x]&amp;y=[y]&amp;z=[z] 其他调用方式不变，使用这种方式之后，融合率几乎是99.99%，如果高德和google结合后还是有无卫星地图的情况，那我暂时也没想到比较好的处理方式了。最终效果如下:","link":"/2019/10/24/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%92%8Cgoogle%E5%9C%B0%E5%9B%BE%E6%95%B4%E5%90%88/"},{"title":"golang下载妹子图","text":"想用golang下载妹子图吗？点进来看看吧!很方便 闲来无趣，就想着看用golang来做点什么事情，这不，到处都是python下载妹子图,我就想着用golang来弄一个下载妹子图的简单小工具 简单分析页面结构访问https://www.meizitu.com 页面后, 进入到详情页面，可以看到url变为https://www.meizitu.com/a/5511.html ，我们将url中的数字任意修改，发现都能访问，那么，我们暂且就通过手动输入页面索引的方式来访问页面。我们再看看页面结构,通过google浏览器的开发者工具很容易就可以看到： 下载图片刚才我们已经大致的分析了页面结构，接下来 ，我们就开始简单的实现图片下载的功能，在这里我们选用了：colly:用于采集页面和图片uuid:生产UUIDcli:命令行工具包1、我们先初始化一个队列，用于存放需要访问的url 1234var q, _ = queue.New( 2, // Number of consumer threads &amp;queue.InMemoryQueueStorage{MaxSize: 10000}, // Use default queue storage ) 2、初始化需要下载的页面，我用命令行的方式来决定起始页 123456789101112if args := context.Args(); len(args) &gt; 0 { return fmt.Errorf(&quot;invalid command: %q&quot;, args.Get(0)) } start := context.Int(&quot;s&quot;) log.Println(&quot;起始页:&quot;, start) end := context.Int(&quot;e&quot;) log.Println(&quot;截止页:&quot;, end) for i := start; i &lt;= end; i++ { url := fmt.Sprintf(&quot;https://www.meizitu.com/a/%d.html&quot;, i) q.AddURL(url)} 3、初始化一个colly来处理队列中的url,我在OnHTML中，查找页面的postContent&gt;img的dom节点，获取图片的路径，又放在队列中 1234567891011121314151617181920c := colly.NewCollector() c.UserAgent = &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot; c.OnHTML(&quot;.postContent&quot;, func(e *colly.HTMLElement) { //e.Request.Visit(e.Attr(&quot;href&quot;)) e.ForEach(&quot;img&quot;, func(i int, element *colly.HTMLElement) { //e.Request.Visit(element.Attr(&quot;src&quot;)) q.AddURL(element.Attr(&quot;src&quot;)) }) }) c.OnResponse(func(resp *colly.Response) { if strings.Contains(resp.Headers.Get(&quot;Content-Type&quot;), &quot;image/jpeg&quot;) { download(resp.Body) } }) c.OnRequest(func(r *colly.Request) { fmt.Println(&quot;Visiting&quot;, r.URL) }) q.Run(c) 最后的效果：代码很简单，如果需要可以去https://github.com/eyiadmin/meizitu 看看，如果想下载图片，就直接下载exe文件。在命令行输入main -s 1 -e 100即可下载 12345678910111213141516171819202122232425main -s 100 -e 1082019/10/07 14:26:42 起始页: 1002019/10/07 14:26:43 截止页: 108Visiting https://www.meizitu.com/a/100.htmlVisiting https://www.meizitu.com/a/101.htmlVisiting https://www.meizitu.com/a/102.htmlVisiting https://www.meizitu.com/a/103.htmlVisiting https://www.meizitu.com/a/104.htmlVisiting https://www.meizitu.com/a/105.htmlVisiting https://www.meizitu.com/a/106.htmlVisiting https://www.meizitu.com/a/107.htmlVisiting https://www.meizitu.com/a/108.htmlVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/01.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/02.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/03.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/04.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/05.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/06.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/30/01.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/07.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/08.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/29/09.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/30/02.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/30/03.jpgVisiting http://pic.topmeizi.com/wp-content/uploads/2012a/01/30/04.jpg","link":"/2019/10/24/golang%E4%B8%8B%E8%BD%BD%E5%A6%B9%E5%AD%90%E5%9B%BE/"},{"title":"微信小程序上传图片到七牛云","text":"微信小程序上传图片到七牛云,小程序Webview嵌入H5上传图片&amp;原生小程序上传图片 最近在帮朋友做微信小程序，没有选择mpvue，因为时间紧加上不熟悉，怕遇到坑不能快速处理，拖了进度，所以采用了原生小程序+webview的方式做了第一版。 小程序webview上传图片因为涉及到H5，所以图片上传这块就用到了微信中的jssdk， 第一步是wx.config配置前端代码如下: 123456789101112131415161718192021222324252627282930313233343536373839abp.services.app.wxAccess.getOfficialAccountJsdkConfig().done(function (data) { if (data) { var appId = data.appId; var timestamp = data.timestamp; var nonceStr = data.noncestr; var signature = data.signature; wx.config({ debug: false, //调试模式 当为tru时，开启调试模式 appId: appId, timestamp: timestamp.toString(), //签名时间戳 nonceStr: nonceStr, //生成签名的随机串 signature: signature, //签名 jsApiList: [&apos;chooseImage&apos;, &apos;uploadImage&apos;], success: function () { alert(&quot;配置成功&quot;); }, fail: function () { alert(&quot;配置失败&quot;); } }); wx.ready(function () { // 在这里调用 API wx.checkJsApi({ jsApiList: [ &apos;chooseImage&apos;, &apos;uploadImage&apos; ], success: function (res) { //console.log(JSON.stringify(res)); } }); }); wx.error(function(res){ alert(JSON.stringify(res)); }); } }); 后端代码： 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 获取公众号JsdkConfig/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;Dtos.GetOfficialAccountJsdkConfigOutput&gt; GetOfficialAccountJsdkConfig() { var input = new Dtos.GetAccessInput { AppId = _appConfiguration[&quot;WechatOfficialAccount:AppId&quot;], Secret = _appConfiguration[&quot;WechatOfficialAccount:Secret&quot;] }; var noncestr = Guid.NewGuid().ToString(&quot;N&quot;); var jsapi = await GetJsapiTicket(input); //var timestamp = (DateTime.Now.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks) / 10000000; var timestamp = new Helper.UnixTime().DateTimeToUnix(DateTime.Now); //var url = Request.UrlReferrer.OriginalString; var url = _iHttpContextAccessor.HttpContext.Request.Headers[Microsoft.Net.Http.Headers.HeaderNames.Referer].ToString(); var shaStr = $&quot;jsapi_ticket={jsapi.Permit}&amp;noncestr={noncestr}&amp;timestamp={timestamp}&amp;url={url}&quot;; var signature = new Helper.Encrypt().Sha1Encrypt(shaStr); return new Dtos.GetOfficialAccountJsdkConfigOutput { AppId = input.AppId, Noncestr = noncestr, Timestamp = timestamp, Signature = signature }; } 第二步就是调用jssdk前端js代码如下： 123456789101112131415161718192021222324252627282930313233wx.chooseImage({ count: 9, needResult: 1, sizeType: [&apos;original&apos;, &apos;compressed&apos;], // 可以指定是原图还是压缩图，默认二者都有 sourceType: [&apos;album&apos;, &apos;camera&apos;], // 可以指定来源是相册还是相机，默认二者都有 success: function (data) { //localIds = data.localIds[0]; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 for (var localId = 0; localId &lt;= data.localIds.length - 1; localId++) { if (isIOS) { wx.getLocalImgData({ localId: data.localIds[localId], // 图片的localID success: function (res) { // var localData = res.localData; // localData是图片的base64数据，可以用img标签显示 //console.log(localData); } }); } else { } } }, fail: function (res) { alert(JSON.stringify(res)); //alterShowMessage(&quot;操作提示&quot;, JSON.stringify(res), &quot;1&quot;, &quot;确定&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); } }); jssdk中，如果是iOS的话，前端无法直接使用localIds资源id做展示，需要调用wx.getLocalImgData方法来获取图片的base64编码 提交前端选择的图片到服务端并由服务的上传到七牛云前端部分代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546wx.uploadImage({ //获取图片媒体ID localId: localIds[erp.common.idx].toString(), // 需要上传的图片的本地ID isShowProgressTips: 1, // 默认为1，显示进度提示 success: function (res) { //获取成功 // 上传序号，上传一张 累计 +1 erp.common.idx++; //存储图片媒体ID，用，号分割 // serverIds += res.serverId + &apos;,&apos;; erp.common.serverIdsArr.push(res.serverId); if (erp.common.idx &lt; localIds.length) { //本地图片ID 还没全部获取完图片媒体ID //调用上传递归函数 erp.common.wxUploadImg(localIds, callback); } else { //上传序号归零 erp.common.idx = 0; //服务器csrf 验证字符串，如果后端框架没开启csrf，则不需要 //alert(erp.common.serverIdsArr); abp.services.app.wxAccess.uploadMediaToQiniu({ WxMediaIds: mediaIds }).done(function (data) { var imageUrl = []; for (var index = 0; index &lt;= data.qiniuFiles.length - 1; index++) { imageUrl.push(data.qiniuFiles[index].qiniuUrl); } $.hideLoading(); callback &amp;&amp; callback(imageUrl); }).always(function(){ $.hideLoading(); }); //serverIds = &apos;&apos;; erp.common.serverIdsArr.length = 0; return true; } }, fail: function (res) { //获取多媒体id失败 返回错误代码 alert(&quot;上传失败，msg：&quot; + JSON.stringify(res)); } }); 后端部分代码: 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 上传文件到七牛/// &lt;/summary&gt;/// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;//[RemoteService(false)]public async Task&lt;Dtos.UploadMediaToQiniuOutput&gt; UploadMediaToQiniu(Dtos.UploadMediaToQiniuInput input){ var output = new Dtos.UploadMediaToQiniuOutput(); if (input.WxMediaIds.Count &gt; 0) { output.QiniuFiles = new System.Collections.Generic.List&lt;Dtos.QiniuFile&gt;(); var access_token = await GetOfficialAccountAccessToken(); var accessKey = _appConfiguration[&quot;Qny:qiniuyunAK&quot;]; var secretKey = _appConfiguration[&quot;Qny:qiniuyunSK&quot;]; var bucket = _appConfiguration[&quot;Qny:qiniuyunBucket&quot;]; var prefixPath = _appConfiguration[&quot;Qny:prefixPath&quot;]; var qiniuStorage = new Helper.QiniuStorage(accessKey, secretKey, bucket); foreach (var mediaId in input.WxMediaIds) { var url = $&quot;https://api.weixin.qq.com/cgi-bin/media/get?access_token={access_token.Permit}&amp;media_id={mediaId}&quot;; var fileKey = qiniuStorage.UploadStream(url); var fileUrl = $&quot;{prefixPath}/{fileKey}&quot;; output.QiniuFiles.Add(new Dtos.QiniuFile { QiniuUrl = fileUrl, WxMediaId = mediaId }); } } return output;} 原生小程序上传图片到七牛云后面考虑到一些交互上面的问题，就把原来的webview方式改成了全原生的模式。采用原生的方式，在图片上传上面就好处理多了，只需要实现获取到七牛云用于上传的token，然后使用wx.uploadFile即可上传。服务端获取token代码： 12345678910111213/// &lt;summary&gt;/// 获取七牛token/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public QiniuTokenOutputDto GetQiniuUpToken(){ var accessKey = _appConfiguration[&quot;Qny:qiniuyunAK&quot;]; var secretKey = _appConfiguration[&quot;Qny:qiniuyunSK&quot;]; var bucket = _appConfiguration[&quot;Qny:qiniuyunBucket&quot;]; var qiniuStorage = new Helper.QiniuStorage(accessKey, secretKey, bucket); var output = new QiniuTokenOutputDto() { UpToken = qiniuStorage.CreateUploadToken() }; return output;} 小程序端部分代码: 12345678910111213141516171819202122232425262728293031323334353637383940411、获取token2、调用小程序API，选择图片。 wx.chooseImage({ count: 9-this.data.cardImgList.length, //默认9 sizeType: [&apos;original&apos;, &apos;compressed&apos;], //可以指定是原图还是压缩图，默认二者都有 sourceType: [&apos;album&apos;, &apos;camera&apos;], //从相册选择 success: (res) =&gt; { res.tempFilePaths.forEach((item,index)=&gt;{ that.upload2Qiniu(item); }); } }); } /*** 图片上传七牛云*/ upload2Qiniu(tempFilePaths) { let token = this.data.token; var that = this; wx.uploadFile({ url: &apos;https://up-z0.qiniup.com&apos;, name: &apos;file&apos;, filePath: tempFilePaths, header: { &quot;Content-Type&quot;: &quot;multipart/form-data&quot; }, formData: { token: that.data.upToken, }, success: function (res) { let data = JSON.parse(res.data) //data.hash图片的资源名，可直接通过域名加资源名访问 // to do ... }, fail: function (res) { console.log(res) } }); } 如果需要更详细的资料，那么就请自行百度or谷歌吧","link":"/2019/10/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91/"},{"title":"基于redis key失效机制实现状态实时更新","text":"基于redis key失效事件通知机制来处理状态实时更新 在我们的业务中，有这样一个场景，在手机端实时采集用用户经纬度，判断用户是否在某个场景(小区、商场等)内,如果再场景内则变更用户任务状态为”执行中”，当用户离开场景超过20分钟，需要将用户任务状态更改为”离场”状态。 一般，我们更新状态，要么定时去扫描数据库，要么就是触发某个事件，在最开始，有想到几种方案：1、定时（采用quartz定时执行作业，去扫描数据库）2、用hangfire、rabbitmq等实现延迟执行3、redis key失效事件，实时处理经过评估，最后选择了redis key失效机制来处理这个业务。 redis key失效事件监听redis自2.8之后就提供Keyspace Notifications功能，允许客户订阅Pub/Sub。 开启事件通知默认情况下，redis是没有开启事件通知的，所以我们需要手动配置： 12打开redis.conf配置文件搜索notify-keyspace-events，该配置默认是被注释掉的，需要将其修改为notify-keyspace-events Ex ,然后重启便可生效 值说明: 1234567891011# K 键空间通知，以__keyspace@&lt;db&gt;__为前缀# E 键事件通知，以__keysevent@&lt;db&gt;__为前缀# g del , expipre , rename 等类型无关的通用命令的通知, ...# $ String命令# l List命令# s Set命令# h Hash命令# z 有序集合命令# x 过期事件（每次key过期时生成）# e 驱逐事件（当key在内存满了被清除时生成）# A g$lshzxe的别名，因此”AKE”意味着所有的事件 spring boot实现消息监听器类pom.xml: 12345678910111213141516171819202122 &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Componentpublic class RedisMsgPubSubListener extends JedisPubSub { private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired ITaskService taskService; @Override public void unsubscribe() { super.unsubscribe(); } @Override public void unsubscribe(String... channels) { super.unsubscribe(channels); } @Override public void subscribe(String... channels) { super.subscribe(channels); } @Override public void psubscribe(String... patterns) { super.psubscribe(patterns); } @Override public void punsubscribe() { super.punsubscribe(); } @Override public void punsubscribe(String... patterns) { super.punsubscribe(patterns); } @Override public void onMessage(String channel, String message) { System.out.println(&quot;channel:&quot; + channel + &quot;receives message :&quot; + message); String key = message; } @Override public void onPMessage(String pattern, String channel, String message) { } @Override public void onSubscribe(String channel, int subscribedChannels) { } @Override public void onPUnsubscribe(String pattern, int subscribedChannels) { } @Override public void onPSubscribe(String pattern, int subscribedChannels) { } @Override public void onUnsubscribe(String channel, int subscribedChannels) { }} 创建一个Runner： 123456789101112131415161718192021public class RedisApplicationRunner implements ApplicationRunner { @Autowired RedisMsgPubSubListener redisMsgPubSubListener; @Autowired JedisPool jedisPool; @Override public void run(ApplicationArguments applicationArguments) throws Exception { Jedis jedis = jedisPool.getResource();// jedis.set(&quot;zhcj:mobile:13548074395:2018122222212&quot;,&quot;1&quot;);// jedis.expire(&quot;zhcj:mobile:13548074395:2018122222212&quot;,10); jedis.subscribe(redisMsgPubSubListener, &quot;__keyevent@0__:expired&quot;); }} 最终效果:","link":"/2019/10/24/%E5%9F%BA%E4%BA%8Eredis-key%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0/"},{"title":"没有java源代码如何修改bug","text":"有时候遇到比较老的产品，公司的产品组也不提供维护了，更可恨的是，源代码也不给。在这种情况，遇到有bug，怎么办呢？ 我们项目组一直在维护着一个2013年基于公司老产品开发的项目，既然是产品，公司产品弄死不肯定提供老产品的代码，原因大概是因为代码管理混乱，已经找不到我们项目的代码了。 这个bug出现在数据授权的时候，按常规组织授权后，下级用户居然能看到上级用户数据，我们的数据授权原理是：获取授权用户所在层级，并获取当前的授权组织表，将组织表数据和当前用户进行匹配，并记录在授权表，然后，用户在查询数据的时候就读取授权表拼接in语句去数据库查询。当出现这个问题的时候，显然是不允许的，这时候，我们的检查步骤是：1、检查用户组织表2、检查授权表3、检查最终执行sql语句通过以上步骤，最终发现是在做sql拼接成in的条件的时候出现的问题，这时候，就只有进入到代码里面一探究竟，由于没有源代码，就只有借用各种反编译工具：1、Java Decompiler2、Jadclipse3、jad4、jd-gui…..等等，还有很多其他的，这里，我选用的是jd-gui，如果是用的idea作为IDE的话，可以直接查看。借助反编译工具反编译出来的代码如下： 12345678910111213141516171819202122static boolean userIsDept(JdbcTemplate sysJdbcTemplate, final String dept, String userId) { String sql = SQLProvider.getSQL(&quot;query.all.sub.dept&quot;); List&lt;String&gt; depts = (List)sysJdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { ps.setString(1, dept); ps.setString(2, dept); } }, new ResultSetExtractor&lt;List&lt;String&gt;&gt;() { public List&lt;String&gt; extractData(ResultSet rs) throws SQLException, DataAccessException { ArrayList trs = new ArrayList(); while(rs.next()) { trs.add(rs.getString(&quot;DEPT_ID&quot;)); } return trs; } }); String userDeptSql = SQLProvider.getSQL(&quot;query.user.dept&quot;); String userDeptId = (String)sysJdbcTemplate.queryForObject(userDeptSql, String.class, new Object[]{userId}); return depts.contains(userDeptId); } 经过分析，发现该处的组织id过多加载，因为在授权表中已经将当前用户所属组织的授权内容全量写进去，这儿过多加载，其实把父组织的授权内容也一并拼接到了in条件内，所以出现这种情况。最后，我通过idea新建一个java项目，把项目的依赖包添加进去，新建了一个同包名、同类名的类，将代码copy进新类，稍作修改，就可导出一个jar包。然后将class文件复制到原来的jar包中覆盖即可，在这里，一定要注意JDK版本，否者会报错。","link":"/2019/11/05/%E6%B2%A1%E6%9C%89java%E6%BA%90%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9bug/"}],"tags":[],"categories":[]}